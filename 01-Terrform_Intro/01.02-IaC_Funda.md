# 01.02 Infrastructure & IaC Fundamentals

## 1. What is Infrastructure?

**Infrastructure** is everything required to **run, secure, and scale an application reliably**.

### Core Infrastructure Components

* **Compute** – Physical or virtual servers (VMs, instances, containers)
* **Networking** – IP addressing, subnets, routing, DNS, load balancers
* **Storage** – Block storage, file systems, object storage
* **Security** – Firewalls, IAM roles, security groups, certificates
* **Operating System & Runtime** – Linux/Windows, libraries, language runtimes

Without infrastructure, **application code is useless**.

### Simple Analogy

| Application World | Real World                      |
| ----------------- | ------------------------------- |
| Application code  | House                           |
| Infrastructure    | Land, water, electricity, roads |

You can design the best house, but **without land and utilities, it cannot exist**.

---

## 2. Infrastructure Models

### 2.1. The Three Infrastructure Types

There are **three main infrastructure models**:

1. On-Premise :

   Infrastructure is **owned, hosted, and managed by the organization** in its own data center. Scaling is manual and costs are upfront.

2. Hybrid : 

   A **combination of on-premise and cloud**, where workloads are split based on security, compliance, or scalability needs.

3. Cloud : 
   
   Infrastructure is **delivered as services over the internet**, provisioned via APIs, scalable on demand, and paid for as you use.

```mermaid
graph LR
    A[Infrastructure Models] --> B[On-Premise]
    A --> C[Hybrid]
    A --> D[Cloud]

    C --> B
    C --> D
```


### 2.2 Deep Dive: On-Premise → Hybrid → Cloud

This diagram shows the **key differences between On-Premise, Hybrid, and Cloud infrastructure**:

* **On-Premise:** You manage everything (high cost, manual operations, high manpower)
* **Hybrid:** Shared responsibilities (mixed cost, complex operations, medium manpower)
* **Cloud:** Provider-managed (OpEx, automated operations, low manpower)

```mermaid
flowchart LR
    OP["On-Premise
- CapEx
- Manual Ops
- High Manpower
- Scalability: Limited"] --> 
    HY["Hybrid
- CapEx + OpEx
- Complex Ops
- Medium Manpower
- Scalability: Moderate"] --> 
    CL["Cloud
- OpEx
- Automated Ops
- Low Manpower
- Scalability: High"]
```

### 2.3 Shared Responsibility Model


> **Shared Responsibility Model** explains how management duties are divided between the customer and the cloud provider.

> In a **Hybrid model**, responsibility is split—some layers are managed by you (on-premise) while others are managed by the cloud provider, based on where the workload runs.



* **On-Premise:** You manage everything
* **Hybrid:** Shared control (on-prem + cloud)
* **IaaS:** Provider manages hardware; you manage OS & apps
* **PaaS:** Provider manages platform; you manage code
* **SaaS:** Provider manages everything

```mermaid
graph TB
    subgraph On-Premise
        OP1[Application]
        OP2[Runtime]
        OP3[OS]
        OP4[Servers]
        OP5[Data Center]
    end

    subgraph Hybrid
        H1[Application - You]
        H2[Runtime - You]
        H3[OS - Mixed]
        H4[Servers - Mixed]
        H5[Data Center - Mixed]
    end

    subgraph IaaS
        IA1[Application]
        IA2[Runtime]
        IA3[OS]
        IA4[Servers - Provider]
        IA5[Data Center - Provider]
    end

    subgraph PaaS
        PA1[Application]
        PA2[Runtime - Provider]
        PA3[OS - Provider]
        PA4[Servers - Provider]
        PA5[Data Center - Provider]
    end

    subgraph SaaS
        SA1[Software - Provider]
        SA2[Everything Managed]
    end

```
---

## 3. Provisioning: What It Means

**Provisioning** is the process of **setting up infrastructure** — servers, networks, storage, and configurations — so applications can run.

There are two types of Provisioning

1. **Manual Provisioning** : Create infra `by click`
2. **Code based Provisioning** : Create infra `by code`

---


```mermaid
flowchart LR
    subgraph Manual["Manual Provisioning"]
        M1[Click Cloud Console]
        M2[Run Ad-hoc CLI Commands]
        M3[Follow Undocumented Steps]
        M1 --> M2 --> M3 --> MFail["Problems:\n- Not Repeatable\n- Error-Prone\n- No Version Control\n- Hard Rollbacks\n- Not Scalable"]
    end

    subgraph Terraform["Code based Provisioning"]
        T1[Write Infrastructure as Code - IaC]
        T2[Version Control via Git]
        T3[Run 'terraform apply']
        T1 --> T2 --> T3 --> TSuccess["Benefits:\n- Repeatable & Consistent\n- Automated & Scalable\n- Trackable Changes\n- Easy Rollbacks"]
    end

    Manual -->|Comparison| Terraform
```
---

### 3.1 Problems with Manual Provisioning

Manual provisioning involves:

* Clicking through cloud consoles
* Running ad-hoc CLI commands
* Following undocumented steps

**Why it fails:**

1. **Not Repeatable** – Hard to recreate the same environment exactly
2. **Error-Prone** – Human mistakes multiply as scale increases
3. **No Version Control** – No track of *who changed what and when*
4. **Difficult Rollbacks** – Undoing mistakes is slow and risky
5. **Not Scalable** – Works for 1 server, fails for 100+

> ⚠ Manual provisioning **cannot survive real-world production environments**.

---

### 3.2 Infrastructure as Code (IaC)

* **Automates provisioning** using code, not clicks
* **Repeatable & Consistent** — same environment every time
* **Version-controlled** — track all changes via Git
* **Scalable** — manages hundreds or thousands of resources easily
* **Declarative** — define *what you want*, Terraform figures out *how to do it*

> Terraform turns **manual, error-prone provisioning** into **reliable, automated, and production-ready infrastructure**.
---

## 4. What is Infrastructure as Code (IaC)?

**Infrastructure as Code (IaC)** means:

> Managing infrastructure using **code files** instead of manual steps

### Core Principles of IaC

* Infrastructure is defined in **files**
* Files are stored in **Git**
* Changes go through **review and approval**
* Infrastructure is created automatically

### Benefits of IaC

* Repeatable
* Version‑controlled
* Automated
* Auditable
* Consistent across environments (dev, test, prod)

### IaC Workflow

```mermaid
flowchart LR
    subgraph Development [Phase 1: Code]
        A[Write IaC Code <br/> 'Terraform/Ansible']
    end

    subgraph Version_Control [Phase 2: Source]
        B[(Git Repository <br/> 'Single Source of Truth')]
    end

    subgraph CI_CD_Pipeline [Phase 3: Execution]
        C{Automation Tool <br/> 'GitHub Actions/Jenkins'}
        C1[(State File)]
    end

    subgraph Production [Phase 4: Target]
        D[Cloud Infrastructure <br/> 'AWS/Azure/GCP']
    end

    %% The Flow
    A -->|git push| B
    B -->|Trigger| C
    C <-->|Track Changes| C1
    C -->|Provision| D

    %% Note for Students
    N1["IaC allows you to rebuild <br/> your entire data center <br/> with one command."]
    N1 --- D

    style C stroke-width:2px,stroke-dasharray: 5 5
```

---

## 5. IaC Tools Overview

### 5.1 Terraform

* Created by **HashiCorp**
* Cloud‑agnostic
* Declarative syntax (HCL)
* Uses a **state file** to track resources

**Best suited for:**

* Multi‑cloud environments
* Standardized infrastructure
* Enterprise‑grade automation

---

### IaC Tool Comparison

Terraform is universal way to create infra for all cloud providers. There are some other IaC tools also prominent as mentioned below :

| Tool           | Cloud Support | Language              |
| -------------- | ------------- | --------------------- |
| Terraform      | Multi‑cloud   | HCL                   |
| CloudFormation | AWS only      | YAML / JSON           |
| ARM / Bicep    | Azure only    | JSON / Bicep          |
| Pulumi         | Multi‑cloud   | Programming languages |

---

## 6. Why Terraform?

Terraform is widely adopted due to **three critical strengths**.

1. **Cloud‑Agnostic**

   * Works across AWS, GCP, Azure, or private clouds
   * Infrastructure code is reusable, not tied to one provider

2. **Declarative Approach**

   * You **define *what* you want**, not *how* to create it
   * Terraform figures out the steps to reach the desired state

3. **State‑Driven Architecture**

   * Maintains a **state file** to track existing resources
   * Ensures changes are **applied incrementally and consistently**
   * Supports **safe updates and rollbacks**
---

### 6.1 Cloud‑Agnostic

* Same tool for AWS, Azure, GCP
* Prevents vendor lock‑in

```mermaid
flowchart TD
    subgraph Language [Infrastructure as Code]
        HCL[Terraform Configuration <br/> '.tf files']
    end

    subgraph Engine [Terraform Core]
        Plan[Plan & State Management]
    end

    subgraph Providers [The Translation Layer]
        P1[AWS Provider]
        P2[Azure Provider]
        P3[GCP Provider]
    end

    subgraph Clouds [Target Infrastructure]
        A[AWS EC2/S3]
        B[Azure VM/Blob]
        C[GCP GCE/Bucket]
    end

    %% Flow
    HCL --> Engine
    Engine --> P1 & P2 & P3
    P1 --> A
    P2 --> B
    P3 --> C

    %% Note for Students
    Note1["The Core stays the same; <br/> only the Provider changes <br/> based on the target cloud."]
    Note1 --- Engine

    style Engine stroke-width:2px
    style Providers stroke-dasharray: 5 5
```

---

### 6.2 Declarative Approach

You define **what you want**, not **how to do it**.

Example:

* Desired state: `1 virtual machine`
* Terraform calculates the steps automatically

**Benefits:**

* Simpler code
* Predictable behavior
* Fewer procedural errors

---

### 6.3 State‑Driven Architecture

Terraform maintains a **state file** that tracks:

* What resources exist
* Current configuration
* Required changes

```mermaid
flowchart TD
    subgraph Config [The Desired State]
        A[Terraform Code <br/> '.tf files']
    end

    subgraph Memory [The Current Knowledge]
        B[(Terraform State File)]
        B1["Mapping: <br/> Code ID <--> Cloud ID"]
    end

    subgraph Reality [The Actual State]
        C[Real Infrastructure <br/> 'AWS/Azure/GCP']
    end

    %% Interactions
    A -->|1. Plan| B
    B <-->|2. Refresh| C
    B -->|3. Apply| C

    %% Note for Students
    Note1["The State File is the 'Bridge'. <br/> If you lose it, Terraform <br/> loses control of your <br/> infrastructure."]
    Note1 --- B

    style B stroke-width:3px
    style Note1 stroke-dasharray: 5 5
```

> **State is the brain of Terraform** — understanding it is mandatory for real‑world usage.

---

## 7. Terraform in DevOps & CI/CD

Terraform plays a key role in **infrastructure automation**.

### DevOps Pipeline View

```mermaid
flowchart TD
    subgraph SCM [Source Control]
        A[Code Commit / <br/> Pull Request]
    end

    subgraph CI [Continuous Integration]
        B[Security Scan & <br/> Syntax Check]
        C[Terraform Plan <br/> 'Preview Changes']
    end

    subgraph CD [Continuous Deployment]
        Gate{Manual <br/> Approval}
        D[Terraform Apply <br/> 'Execute']
    end

    subgraph Target [Cloud]
        E((Infrastructure <br/> Live))
    end

    %% Flow
    A --> B
    B --> C
    C --> Gate
    Gate -- "Approved" --> D
    D --> E

    %% Note for Students
    Note1["The 'Plan' step shows you <br/> exactly what will happen <br/> before it costs money."]
    Note1 --- C

    style Gate stroke-width:2px,stroke-dasharray: 5 5
    style E stroke-width:3px
```

### Key Takeaways

* Infrastructure is created **before application deployment**
* Changes are predictable and reviewable
* Environments remain consistent

---

## Final Summary

* Infrastructure is the foundation of applications
* Manual provisioning does not scale
* IaC brings automation, consistency, and safety
* Terraform is the industry standard for IaC

> **Master Terraform → Master modern infrastructure automation**

## 02.04 Terraform Workflow Overview

Terraform manages infrastructure through **three major workflows**:

1. **Code → Infrastructure creation**
2. **Infrastructure → Code**
3. **Code Drift detection & correction**

These steps ensure:

* Safety
* Predictability
* Controlled changes
---

## 1️. Code → Infrastructure Creation

This is the **standard Terraform workflow** where infrastructure is created from code.

**Flow:**

* Write Terraform code (`.tf`)
* Initialize providers and backend
* Generate execution plan
* Apply changes to create infrastructure
* Store results in state file

**Key commands:**


* terraform init
* terraform plan
* terraform apply
* terraform destroy


### Mermaid Diagram – Code to Infra

```mermaid
flowchart TD
    linkStyle default interpolate basis

    subgraph Preparation [1. Initializing]
        A[Terraform Code <br/> '.tf files'] --> B[terraform init]
    end

    subgraph Review [2. Previewing]
        B --> C[terraform plan]
    end

    subgraph Execution [3. Deploying]
        C --> D[terraform apply]
    end

    subgraph Results [4. Output]
        direction LR
        D --> E[Real Infrastructure]
        D --> F[Terraform State]
    end

    %% Note for Students
    Note1["Downloads Providers <br/> & Modules"]
    Note2["Calculates the <br/> Delta (Changes)"]
    
    B --- Note1
    C --- Note2

```

> Terraform compares **desired state (code)** with **current state (state file)** before making changes.

---

## 2. Infrastructure → Code Creation (Import)

This workflow is used when infrastructure **already exists** but is **not managed by Terraform**.

**Why this is needed:**

* Manual infrastructure
* Legacy environments
* Resources created outside Terraform

**Flow:**

* Write empty resource block
* Import existing resource into state
* Terraform updates the state
* User aligns code with imported state

**Key command:**

```bash
terraform import
```

### Mermaid Diagram – Infra to Code (Import)

```mermaid
flowchart TD
    linkStyle default interpolate basis

    subgraph Cloud [The Reality]
        A[Existing Resource <br/> 'Manually Created']
    end

    subgraph Command [The Bridge]
        B[terraform import <br/> 'ADDRESS ID']
    end

    subgraph Logic [The Sync]
        C[Terraform State <br/> 'Memory Updated']
        D[Terraform Code <br/> 'HCL Definition']
    end

    %% Process Flow
    A -->|1. Identify ID| B
    B -->|2. Pull Metadata| C
    D -.->|3. Align Syntax| C
    
    %% Status Check
    C --- Result{In Sync?}
    Result -->|Yes| Success[Infrastructure <br/> Managed]

```

> `terraform import` **does not generate code** — it only updates the **state file**.

---

## 3. Code Drift (Drift Detection & Correction)

**Code drift** occurs when infrastructure is modified **outside Terraform**.

**Examples:**

* Manual changes in cloud console
* Scripts altering resources
* Auto-scaling or policy updates

**Flow:**

* Terraform compares code vs real infra
* Drift is detected during `plan`
* Terraform proposes corrective actions

**Key command:**

```bash
terraform plan
```

### Code Drift Workflow

```mermaid
flowchart TD
    linkStyle default interpolate basis

    subgraph Desired_State [The Source of Truth]
        A[Terraform Code <br/> '.tf files']
    end

    subgraph Comparison_Engine [The Audit]
        B[terraform plan]
        D{Drift Detected?}
    end

    subgraph Reality [The Actual Cloud]
        C[Real Infrastructure <br/> 'AWS / Azure / GCP']
    end

    subgraph Resolution [The Healing]
        E[terraform apply]
    end

    %% Flow
    A -->|Desired| B
    C -->|Current| B
    B --> D
    D -->|Yes: Manual Change Found| E
    D -->|No: In Sync| Success[No Action Needed]
    E -->|Restore Integrity| C
```
> Terraform always trusts **code as the source of truth**.

---

## Overall Three Terraform Workflow (Combined)

### Mermaid Diagram – Complete Terraform Lifecycle

```mermaid
flowchart TD
    linkStyle default interpolate basis

    subgraph Standard_Workflow [1. Creation: Code to Cloud]
        direction TB
        Code[Terraform Code] --> Init[terraform init]
        Init --> Plan[terraform plan]
        Plan --> Apply[terraform apply]
        Apply --> Infra[Real Infrastructure]
        Apply --> State[Terraform State]
    end

    subgraph Reverse_Engineering [2. Import: Cloud to Code]
        direction TB
        Infra_Existing[Existing Resource] --> ImportCmd[terraform import]
        ImportCmd --> State
        State -.->|Refactoring| Code
    end

    subgraph Maintenance [3. Drift Detection]
        direction TB
        Infra -->|Current Reality| Refresh[Plan / Refresh]
        Refresh -->|Compare| Drift{Drift Detected?}
        Drift -->|Yes| Apply
        Drift -->|No| Success[In Sync]
    end
```

---


## 6. Idempotency Concept

Idempotency means:

> Running the same command multiple times gives the same result.

In Terraform:

* If infrastructure matches the configuration
* `terraform apply` does nothing

Why idempotency matters:

* Safe re-runs
* Reliable automation
* Predictable infrastructure

```mermaid
flowchart LR
    A[Terraform Code] --> B[terraform apply]
    B --> C{Infra Matches Code?}
    C -- Yes --> D[No Changes]
    C -- No --> E[Apply Required Changes]
    E --> F[Infrastructure Updated]
    F --> B
```

---

## 7. Dependency Graph (Implicit & Explicit)

Terraform automatically understands dependencies.

### Implicit Dependency

* Created when one resource references another.

* Terraform detects order automatically.

### Explicit Dependency

* Used when dependency is not obvious.

* Declared using `depends_on`.

```mermaid
flowchart TD
    subgraph Implicit["Implicit Dependency (Auto-detected)"]
        A1[Resource A<br/>e.g., VPC]
        B1[Resource B<br/>e.g., Subnet]
        A1 -->|Attribute Reference| B1
    end

    subgraph Explicit["Explicit Dependency (depends_on)"]
        A2[Resource X<br/>IAM Role]
        B2[Resource Y<br/>EC2 Instance]
        A2 -->|depends_on| B2
    end

```

Terraform builds a dependency graph before applying changes.

Why this matters:

* Correct creation order
* Safe deletion order
* Parallel execution when possible

---

